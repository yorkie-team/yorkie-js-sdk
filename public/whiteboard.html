<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Whiteboard Example</title>
    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="whiteboard.css" />
  </head>
  <body>
    <div class="canvas">
      <div class="toolbar">
        <button class="rectangle">◼️ (new!)</button>
        <button class="undo">⬅ undo</button>
        <button class="redo">➡️ redo</button>
      </div>
      <div class="shapes"></div>
      <div class="selection-tools">
        <div class="color-picker">
          <button class="color" data-color="orangered"></button>
          <button class="color" data-color="gold"></button>
          <button class="color" data-color="limegreen"></button>
          <button class="color" data-color="dodgerblue"></button>
          <button class="color" data-color="darkviolet"></button>
          <button class="color" data-color="darkorange"></button>
          <button class="color" data-color="dimgray"></button>
          <button class="color" data-color="white"></button>
        </div>
      </div>
    </div>
    <div class="obj-dev-tool">
      <div id="network-status"></div>
      <div id="online-clients"></div>
      <div class="obj-dev-log">
        <div>
          <h2>yorkie document</h2>
          <div id="document-holder"></div>
        </div>
        <div class="stack-holder">
          <div>
            <h2>operations</h2>
            <div id="ops-holder" class="ops-holder"></div>
          </div>
        </div>
        <div class="stack-holder">
          <div>
            <h2>undo stack</h2>
            <div id="undo-holder" class="ops-holder"></div>
          </div>
          <div>
            <h2>redo stack</h2>
            <div id="redo-holder" class="ops-holder"></div>
          </div>
        </div>
      </div>
    </div>
    <script src="./yorkie.js"></script>
    <script src="./util.js"></script>
    <script type="module">
      const statusHolder = document.getElementById('network-status');
      const onlineClientsHolder = document.getElementById('online-clients');
      const undoHolder = document.getElementById('undo-holder');
      const redoHolder = document.getElementById('redo-holder');
      const opsHolder = document.getElementById('ops-holder');
      const docHolder = document.getElementById('document-holder');

      function renderOpsHolder(changes, idPrefix) {
        return changes
          .map((ops, i) => {
            const opsStr = ops
              .map((op) => {
                if (op.type === 'presence') {
                  return `<span class="op"><span class="type presence">presence</span>${JSON.stringify(
                    op.value,
                  )}</span>`;
                }
                let id = op.getExecutedAt()?.toTestString();
                if (id) {
                  id = `<span class="timeticket">${id}</span>`;
                }
                const opType = op.toTestString().split('.')[1];
                return `<span class="op">
                  <span class="type ${opType.toLowerCase()}">${opType}</span>
                  ${id ? id : ''}
                  ${op.toTestString()}
                </span>`;
              })
              .join('\n');
            return `
              <div class="change">
                <input type="checkbox" id="${idPrefix}-${i}" />
                <label for="${idPrefix}-${i}">
                  <span class="count">${ops.length}</span>
                  <span class="ops">${opsStr}</span>
                </label>
              </div>
            `;
          })
          .join('');
      }

      function printOps(doc) {
        opsHolder.innerHTML = renderOpsHolder(doc.getOpsForTest(), 'op');
        undoHolder.innerHTML = renderOpsHolder(
          doc.getUndoStackForTest(),
          'undo',
        );
        redoHolder.innerHTML = renderOpsHolder(
          doc.getRedoStackForTest(),
          'redo',
        );
      }

      const displayDocument = (doc) => {
        const docData = doc.getRoot().toJSForTest();
        docHolder.innerHTML = displayObject(docData);
      };
      function displayObject({ key, value, id }) {
        const valueHTML = Object.values(value)
          .map((v) => {
            return Object.prototype.toString.call(v.value) === '[object Object]'
              ? displayObject(v)
              : displayValue(v);
          })
          .join('');
        if (!key) key = 'root';
        return `
          <div class="object-key-val">
              ${displayKey({ key, id })}
              <div class="object-content">
                  ${valueHTML}
              </div>
          </div>
          `;
      }
      function displayKey({ key, id }) {
        return `
          <input type="checkbox" id="${id}" />
          <label for="${id}">${key}
              <span class="timeticket">${id}</span>
          </label>
          `;
      }
      function displayValue({ key, value, id }) {
        return `
          <div class="variable-row">
              <span>${key} : ${JSON.stringify(value)}
                  <span class="timeticket">${id}</span>
              </span>
          </div>
          `;
      }

      const undoTool = document.querySelector('.toolbar .undo');
      const redoTool = document.querySelector('.toolbar .redo');
      const deleteTool = document.querySelector('.toolbar .delete');
      const rectangleTool = document.querySelector('.toolbar .rectangle');
      const shapesHolder = document.querySelector('.canvas .shapes');
      const selectionTool = document.querySelector('.selection-tools');
      const colorPicker = document.querySelector(
        '.selection-tools .color-picker',
      );
      const COLORS = [
        'orangered',
        'gold',
        'limegreen',
        'dodgerblue',
        'darkviolet',
      ];
      const rectangleSize = 50;
      let isDragging = false;

      function getRandomInt(max) {
        return Math.floor(Math.random() * max);
      }

      function getRandomColor() {
        return COLORS[getRandomInt(COLORS.length)];
      }

      function renderShapes(doc, myClientID) {
        const shapes = doc.getRoot().shapes;
        if (!shapes) return;
        shapesHolder.innerHTML = '';
        for (const shape of shapes) {
          const shapeElement = document.createElement('div');
          shapeElement.className = 'shape';
          shapeElement.style.transform = `translate(${shape.point.x}px, ${shape.point.y}px)`;
          shapeElement.style.backgroundColor = shape.color;
          const selectedByMe = doc.getMyPresence().selectedShape === shape.id;
          const selectedByOthers = doc
            .getPresences()
            .some(
              ({ clientID, presence }) =>
                presence.selectedShape === shape.id && clientID !== myClientID,
            );
          const selectionColor = selectedByMe
            ? 'blue'
            : selectedByOthers
            ? 'orange'
            : 'transparent';
          shapeElement.style.borderColor = selectionColor;
          shapeElement.setAttribute('data-id', shape.id);

          shapesHolder.appendChild(shapeElement);
          shapeElement.addEventListener('pointerdown', (e) => {
            e.stopPropagation();
            const currentSelectedShapeId = doc.getMyPresence().selectedShape;
            isDragging = true;
            if (currentSelectedShapeId === shape.id) return;
            doc.update((root, presence) => {
              presence.set({ selectedShape: shape.id }, { addToHistory: true });
            });
          });
        }
      }

      const onCanvasPointerUp = (e, doc) => {
        if (!isDragging) {
          doc.update((root, presence) => {
            presence.set({ selectedShape: null }, { addToHistory: true });
          });
        }
        const selectedShapeId = doc.getMyPresence().selectedShape;
        isDragging = false;
      };
      const onCanvasPointerMove = (e, doc) => {
        if (!isDragging) return;
        const selectedShapeId = doc.getMyPresence().selectedShape;

        doc.update((root, presence) => {
          const selectedShape = root.shapes.find(
            (shape) => shape.id === selectedShapeId,
          );
          if (!selectedShape) return;
          selectedShape.point = {
            x: e.clientX - rectangleSize / 2,
            y: e.clientY - rectangleSize / 2,
          };
        });
      };
      function displayOnlineClients(presences, myClientID) {
        const usernames = [];
        for (const { clientID, presence } of presences) {
          usernames.push(
            clientID === myClientID ? `<b>${clientID}</b>` : clientID,
          );
        }
        onlineClientsHolder.innerHTML = JSON.stringify(usernames);
      }

      async function main() {
        try {
          // 01. create client with RPCAddr(envoy) then activate it.
          const client = new yorkie.Client('http://localhost:8080');
          client.subscribe(network.statusListener(statusHolder));
          await client.activate();
          const myClientID = client.getID();

          // 02. create a document then attach it into the client.
          const doc = new yorkie.Document('whiteboard');
          doc.subscribe('presence', (event) => {
            if (event.type === 'presence-changed') {
              renderShapes(doc, myClientID);
            }
            displayOnlineClients(doc.getPresences(), client.getID());
          });
          doc.subscribe('my-presence', (event) => {
            if (event.type === 'presence-changed') {
              if (event.value.presence?.selectedShape) {
                selectionTool.style.display = 'flex';
              } else {
                selectionTool.style.display = 'none';
              }
            }
          });
          await client.attach(doc);

          shapesHolder.addEventListener('pointerup', (e) => {
            onCanvasPointerUp(e, doc);
          });
          shapesHolder.addEventListener('pointermove', (e) => {
            onCanvasPointerMove(e, doc);
          });

          // 04. subscribe to document changes
          doc.subscribe((event) => {
            displayDocument(doc);
            renderShapes(doc, myClientID);
            printOps(doc);
          });

          // 05. set initial value
          doc.update((root) => {
            if (!root.shapes) {
              root.shapes = [];
            }
          });
          displayDocument(doc);
          renderShapes(doc, myClientID);
          printOps(doc);

          const insertRectangle = () => {
            const shapeId = Date.now().toString();
            doc.update((root, presence) => {
              root.shapes.push({
                id: shapeId,
                point: {
                  x: getRandomInt(300),
                  y: getRandomInt(300),
                },
                color: getRandomColor(),
              });
              presence.set({ selectedShape: shapeId }, { addToHistory: true });
            });
          };
          const setColor = (e) => {
            if (!e.target.dataset.color) return;
            const selectedShapeId = doc.getMyPresence().selectedShape;
            doc.update((root) => {
              const selectedShape = root.shapes.find(
                (shape) => shape.id === selectedShapeId,
              );
              if (!selectedShape) return;
              selectedShape.color = e.target.dataset.color;
            });
          };
          rectangleTool.onclick = insertRectangle;
          undoTool.onclick = doc.history.undo;
          redoTool.onclick = doc.history.redo;
          colorPicker.onclick = setColor;
        } catch (e) {
          console.error(e);
        }
      }

      main();
    </script>
  </body>
</html>
